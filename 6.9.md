## 239.滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

解题思路：**单调队列**

- 每次保证 deque 中的元素单调递减，即开头为最大的元素，每次只需要通过 deque 中的元素个数来确定是否需要在队尾加入元素

![](https://github.com/SorryQin/lconcemore/blob/main/data/6.9.png)

实现代码如下：

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;      // 存储元素索引的双端队列
        vector<int> result; // 存储每个窗口的最大值

        // 处理特殊情况：如果数组长度小于窗口大小，直接返回空结果
        if (nums.size() < k)  return result;
        
        // 遍历数组中的每个元素
        for (int i = 0; i < nums.size(); i++) {
            // 步骤1：移除已经不在当前窗口的元素索引
            if (!dq.empty() && dq.front() == i - k) 
                dq.pop_front();
            
            // 步骤2：维护队列的单调性，确保队首元素是当前窗口的最大值
            // 从队尾移除所有小于当前元素的索引，因为它们不可能是后续窗口的最大值
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            
            // 步骤3：将当前元素索引入队
            dq.push_back(i);

            // 步骤4：当窗口形成后，开始记录每个窗口的最大值
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        
        return result;
    }
};
```

- 代码里面有点难看的地方主要是 **步骤1** 中，为什么要判断 **dq.front() == i - k**，因为这里dq数组中存的是数字对应的 **序号** 而不是 **数值**。
